-- ============================================
-- Order Service - Schema Creation
-- ============================================
--
-- Este script crea las tablas para Order Service:
-- - orders: Agregado raíz, contiene información principal de la orden
-- - order_items: Entidades hijas, items individuales de cada orden
-- - processed_events: Tabla de deduplicación para idempotencia
--
-- Decisiones de diseño:
-- - UUIDs en lugar de BIGSERIAL para IDs (mejor para sistemas distribuidos)
-- - NUMERIC para montos monetarios (evita errores de redondeo de FLOAT/DOUBLE)
-- - Timestamps con zona horaria (timestamptz)
-- - Constraints explícitos con nombres (facilita debugging)
-- - Índices para queries comunes (customer_id, status, created_at)
--
-- Orden de ejecución: Después de 01-init-databases.sql
-- ============================================

-- ============================================
-- Tabla: orders
-- ============================================
-- Agregado raíz del bounded context Orders.
-- Contiene toda la información de una orden excepto los items (en tabla separada).

CREATE TABLE IF NOT EXISTS orders (
    -- Primary Key
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- Foreign Keys (lógicos - no hay FK real porque Customer está en otro servicio)
    customer_id UUID NOT NULL,

    -- Estado de la orden (máquina de estados definida en domain-model-design.md)
    -- Valores posibles: PENDING, CONFIRMED, PAYMENT_PROCESSING, PAID, SHIPPED, DELIVERED, CANCELLED, FAILED
    status VARCHAR(50) NOT NULL,

    -- Montos monetarios
    -- NUMERIC(19, 4) soporta hasta 999,999,999,999,999.9999 con 4 decimales de precisión
    -- Por qué no DECIMAL? Son sinónimos en PostgreSQL, pero NUMERIC es el estándar SQL
    total_amount NUMERIC(19, 4) NOT NULL,

    -- Código de moneda ISO 4217 (COP, USD, EUR, etc)
    currency VARCHAR(3) NOT NULL DEFAULT 'COP',

    -- Optimistic Locking
    -- Se incrementa en cada UPDATE para detectar conflictos de concurrencia
    version INTEGER NOT NULL DEFAULT 0,

    -- Auditoría
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CONSTRAINT chk_total_amount_positive CHECK (total_amount > 0),
    CONSTRAINT chk_status_valid CHECK (
        status IN ('PENDING', 'CONFIRMED', 'PAYMENT_PROCESSING', 'PAID', 'SHIPPED', 'DELIVERED', 'CANCELLED', 'FAILED')
    ),
    CONSTRAINT chk_currency_valid CHECK (LENGTH(currency) = 3)
);

-- Índices para Orders
-- Estos índices aceleran las queries más comunes del sistema

-- Búsqueda por cliente (GET /api/v1/orders?customerId=xxx)
CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders(customer_id);

-- Búsqueda por estado (dashboards, métricas)
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);

-- Ordenar por fecha de creación (GET /api/v1/orders?sort=createdAt,desc)
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at DESC);

-- Índice composite para búsquedas combinadas (cliente + estado)
-- Ejemplo: "Órdenes del cliente X en estado PENDING"
-- PostgreSQL puede usar este índice para queries con ambos campos o solo customer_id
-- Pero NO para queries solo con status (el orden importa)
CREATE INDEX IF NOT EXISTS idx_orders_customer_status ON orders(customer_id, status);

-- Comentarios en la tabla (documentación en la base de datos)
COMMENT ON TABLE orders IS 'Order aggregate root - Contains main order information';
COMMENT ON COLUMN orders.id IS 'Primary key - UUID generated by database';
COMMENT ON COLUMN orders.customer_id IS 'Logical FK to Customer (in another service)';
COMMENT ON COLUMN orders.status IS 'Order state machine status';
COMMENT ON COLUMN orders.total_amount IS 'Total order amount - NUMERIC for precision';
COMMENT ON COLUMN orders.currency IS 'ISO 4217 currency code';
COMMENT ON COLUMN orders.version IS 'Optimistic locking version';

-- ============================================
-- Tabla: order_items
-- ============================================
-- Entidades que pertenecen al agregado Order.
-- No tienen identidad fuera del contexto de una orden.

CREATE TABLE IF NOT EXISTS order_items (
    -- Primary Key
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- Foreign Key a Orders
    -- ON DELETE CASCADE: Si se borra una orden, se borran sus items automáticamente
    -- Esto mantiene consistencia referencial (no queremos items huérfanos)
    order_id UUID NOT NULL,

    -- Información del producto
    -- product_id: FK lógico a Product (en otro servicio/bounded context)
    -- product_name: Denormalizado intencionalmente - queremos el nombre en el momento de la compra
    product_id UUID NOT NULL,
    product_name VARCHAR(255) NOT NULL,

    -- Cantidad y precios
    quantity INTEGER NOT NULL,
    unit_price NUMERIC(19, 4) NOT NULL,

    -- Subtotal calculado y guardado (quantity * unit_price)
    -- Sí, es redundante. Sí, facilita queries y previene errores de redondeo.
    subtotal NUMERIC(19, 4) NOT NULL,

    -- Auditoría
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CONSTRAINT fk_order_items_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    CONSTRAINT chk_quantity_positive CHECK (quantity > 0),
    CONSTRAINT chk_unit_price_positive CHECK (unit_price > 0),
    CONSTRAINT chk_subtotal_positive CHECK (subtotal > 0)
    -- NOTE: Removed chk_subtotal_calculated constraint to avoid floating-point rounding errors
    -- Instead, we use a trigger (below) to automatically calculate subtotal on INSERT/UPDATE
    -- This guarantees subtotal = quantity * unit_price without constraint violations
);

-- Índices para Order Items

-- FK index - PostgreSQL NO crea índice automático en FKs (a diferencia de MySQL)
-- Este índice acelera JOINs y ON DELETE CASCADE
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items(order_id);

-- Búsqueda por producto (para análisis: "qué órdenes compraron producto X")
CREATE INDEX IF NOT EXISTS idx_order_items_product_id ON order_items(product_id);

COMMENT ON TABLE order_items IS 'Order items - Entities belonging to Order aggregate';
COMMENT ON COLUMN order_items.order_id IS 'FK to orders - CASCADE delete';
COMMENT ON COLUMN order_items.product_name IS 'Denormalized - captures name at purchase time';
COMMENT ON COLUMN order_items.subtotal IS 'Calculated and stored - quantity * unit_price';

-- ============================================
-- Tabla: processed_events
-- ============================================
-- Tabla de deduplicación para garantizar idempotencia.
--
-- Problema: Kafka puede entregar eventos duplicados (at-least-once delivery)
-- Solución: Antes de procesar evento, verificamos si event_id ya está en esta tabla
--
-- Esta tabla es CRÍTICA. Sin ella, podrías procesar eventos dos veces y causar
-- bugs como "orden confirmada dos veces" o "pago duplicado".

CREATE TABLE IF NOT EXISTS processed_events (
    -- Primary Key: event_id debe ser único
    -- Si INSERT falla por violación de PK, sabemos que el evento ya se procesó
    event_id VARCHAR(36) PRIMARY KEY,

    -- Tipo de evento (OrderCreatedEvent, OrderConfirmedEvent, etc)
    event_type VARCHAR(100) NOT NULL,

    -- Aggregate ID del evento (order_id en la mayoría de casos)
    aggregate_id VARCHAR(36) NOT NULL,

    -- Timestamp de procesamiento
    processed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Version del servicio que procesó el evento
    -- Útil para debugging: "todos los eventos procesados por v1.0.0"
    service_version VARCHAR(20) NOT NULL
);

-- Índices para Processed Events

-- Búsqueda por aggregate (todos los eventos de order-123)
CREATE INDEX IF NOT EXISTS idx_processed_events_aggregate_id ON processed_events(aggregate_id);

-- Búsqueda por tipo de evento
CREATE INDEX IF NOT EXISTS idx_processed_events_type ON processed_events(event_type);

-- Búsqueda por timestamp (para limpiar eventos antiguos)
CREATE INDEX IF NOT EXISTS idx_processed_events_processed_at ON processed_events(processed_at DESC);

COMMENT ON TABLE processed_events IS 'Event deduplication table - Ensures idempotency';
COMMENT ON COLUMN processed_events.event_id IS 'Event UUID - Primary Key ensures uniqueness';
COMMENT ON COLUMN processed_events.aggregate_id IS 'Order ID or other aggregate ID';
COMMENT ON COLUMN processed_events.service_version IS 'Service version that processed the event';

-- ============================================
-- Function: Actualizar updated_at automáticamente
-- ============================================
-- Esta función se llama automáticamente en cada UPDATE a la tabla orders
-- Actualiza updated_at al timestamp actual

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para orders
CREATE TRIGGER update_orders_updated_at
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- Function: Incrementar version en cada UPDATE (Optimistic Locking)
-- ============================================
-- Esta función incrementa automáticamente el campo 'version' en cada UPDATE
-- Si dos transacciones intentan actualizar la misma orden simultáneamente,
-- la segunda falla con error de version mismatch

CREATE OR REPLACE FUNCTION increment_version_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.version = OLD.version + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para orders
CREATE TRIGGER increment_orders_version
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION increment_version_column();

-- ============================================
-- Function: Calcular subtotal automáticamente
-- ============================================
-- Esta función calcula automáticamente el subtotal de un order_item
-- antes de INSERT o UPDATE. Esto previene errores de redondeo y garantiza
-- que subtotal SIEMPRE sea igual a quantity * unit_price.
--
-- Por qué un trigger en lugar de un constraint?
-- - NUMERIC arithmetic puede tener diferencias minúsculas en redondeo
-- - Un constraint CHECK puede fallar si el cliente calcula subtotal manualmente
-- - El trigger SIEMPRE recalcula, garantizando consistencia
--
-- Desventaja: El cliente no controla el subtotal (siempre se sobrescribe)
-- Ventaja: Imposible tener datos inconsistentes

CREATE OR REPLACE FUNCTION calculate_order_item_subtotal()
RETURNS TRIGGER AS $$
BEGIN
    -- Calcular subtotal basado en quantity y unit_price
    -- NUMERIC * INTEGER = NUMERIC (sin pérdida de precisión)
    NEW.subtotal = NEW.quantity * NEW.unit_price;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para order_items - Se ejecuta en INSERT y UPDATE
-- BEFORE: Modifica NEW antes de escribir a disco
CREATE TRIGGER calculate_order_items_subtotal
    BEFORE INSERT OR UPDATE ON order_items
    FOR EACH ROW
    EXECUTE FUNCTION calculate_order_item_subtotal();

COMMENT ON FUNCTION calculate_order_item_subtotal() IS 'Auto-calculates subtotal for order_items - Prevents rounding errors';

-- Logging
DO $$
BEGIN
    RAISE NOTICE '✓ Order Service tables created successfully';
    RAISE NOTICE '  - orders (with indexes and triggers)';
    RAISE NOTICE '  - order_items (with FK cascade)';
    RAISE NOTICE '  - processed_events (idempotency)';
END
$$;
