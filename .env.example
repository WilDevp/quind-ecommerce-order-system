# ============================================
# E-commerce Order System - Environment Variables
# ============================================
#
# Este archivo contiene TODAS las variables de entorno necesarias para correr el sistema.
#
# IMPORTANTE: NO commitees el archivo .env con valores reales. Este .env.example es la plantilla.
#
# ============================================
# QUICK START - Get Running in 2 Minutes
# ============================================
#
# 1. Copy this file:
#    cp .env.example .env
#
# 2. (Optional) Keep defaults for development, or customize values below
#
# 3. Start infrastructure only (databases + Kafka):
#    docker-compose up -d postgres mongodb kafka zookeeper
#
# 4. Check everything is healthy:
#    docker-compose ps
#    (All services should show "healthy" status)
#
# 5. (Optional) Start all services including microservices:
#    docker-compose --profile services up -d
#
# 6. Access services:
#    - Kafka UI: http://localhost:8090
#    - PostgreSQL: localhost:5432 (user: ecommerce_user, password: ecommerce_pass)
#    - MongoDB: localhost:27017 (user: admin, password: admin_pass)
#    - Order Service: http://localhost:8080
#    - Payment Service: http://localhost:8081
#    - Notification Service: http://localhost:8082
#
# That's it! You're running a complete event-driven microservices system.
#
# ============================================
# CONFIGURATION
# ============================================
# Adjust the values below according to your environment (development, staging, production)
# The .env file is in .gitignore - never commit it with real credentials
#
# ============================================

# --------------------------------------------
# PostgreSQL - Base de Datos Transaccional
# --------------------------------------------
# PostgreSQL almacena datos transaccionales (Orders, Payments) que requieren ACID.
# En producción, usa un cluster con read replicas. En desarrollo, single instance está bien.

POSTGRES_DB=ecommerce
POSTGRES_USER=ecommerce_user
POSTGRES_PASSWORD=ecommerce_pass
POSTGRES_PORT=5432

# Notas:
# - POSTGRES_PASSWORD: En producción usa un password fuerte (16+ caracteres, alfanumérico + símbolos)
# - POSTGRES_PORT: Cambiar solo si tienes conflicto con otra instancia de Postgres en tu máquina

# --------------------------------------------
# MongoDB - Event Store y Notificaciones
# --------------------------------------------
# MongoDB almacena eventos inmutables (event sourcing) y notificaciones.
# Schema flexible y excelente para append-only workloads.

MONGO_ROOT_USER=admin
MONGO_ROOT_PASSWORD=admin_pass
MONGO_DATABASE=ecommerce_events
MONGO_PORT=27017

# Notas:
# - MONGO_ROOT_USER/PASSWORD: Credenciales del admin. Los servicios se conectan con estas credenciales.
# - MONGO_DATABASE: Nombre de la base de datos. Los servicios crean collections aquí automáticamente.
# - En producción: Usa MongoDB replica set (3+ nodos) para HA. Ajusta connection string en servicios.

# --------------------------------------------
# Apache Kafka - Message Broker
# --------------------------------------------
# Kafka maneja comunicación asíncrona entre servicios vía eventos.
# Los servicios publican eventos a topics, otros servicios los consumen.

KAFKA_PORT=9092
ZOOKEEPER_PORT=2181
KAFKA_UI_PORT=8090

# Notas:
# - KAFKA_PORT: Puerto para clientes externos (localhost:9092). Internamente usa kafka:29092.
# - ZOOKEEPER_PORT: Kafka depende de Zookeeper para coordinación. Eventualmente Kafka eliminará esta dependencia (KRaft).
# - KAFKA_UI_PORT: Interfaz web para monitorear topics, consumers, mensajes. Útil para debugging.
#   Accede en http://localhost:8090 después de iniciar Docker Compose.

# --------------------------------------------
# Spring Profiles
# --------------------------------------------
# Spring Boot usa profiles para configuraciones específicas de entorno.
# Los valores pueden ser: local, docker, dev, staging, prod

SPRING_PROFILES_ACTIVE=docker

# Profiles explicados:
# - local: Para correr servicios directamente en tu IDE, conectándose a infra en Docker
# - docker: Para correr servicios dentro de Docker Compose (todos los containers en misma red)
# - dev/staging/prod: Para ambientes reales con configuración específica

# --------------------------------------------
# Order Service - Puerto 8080
# --------------------------------------------
# Order Service maneja el ciclo de vida completo de órdenes.

ORDER_SERVICE_PORT=8080

# Notas:
# - Todas las configuraciones de DB y Kafka están en docker-compose.yml como environment variables
# - Este puerto solo controla el mapeo externo (localhost:8080 → container:8080)

# --------------------------------------------
# Payment Service - Puerto 8081
# --------------------------------------------
# Payment Service procesa pagos con gateways externos (Stripe, PayPal).

PAYMENT_SERVICE_PORT=8081

# Configuración del Payment Gateway
PAYMENT_GATEWAY_URL=https://api.stripe.com
PAYMENT_GATEWAY_API_KEY=sk_test_dummy

# Notas:
# - PAYMENT_GATEWAY_URL: URL del gateway. Para desarrollo usa test environment de Stripe/PayPal.
# - PAYMENT_GATEWAY_API_KEY: API key del gateway. NUNCA commitees la key real.
#
#   Formato de API keys reales:
#   Stripe Test:       sk_test_51ABCDefghijklMNOPqrstuvWXYZ123456789...
#   Stripe Production: sk_live_51ABCDefghijklMNOPqrstuvWXYZ123456789...
#   PayPal Sandbox:    AXYZ123456789ABCDEFGhijklmnopQRSTuvwXYZ (client ID)
#
#   Para obtener tu key:
#   - Stripe: https://dashboard.stripe.com/apikeys
#   - PayPal: https://developer.paypal.com/dashboard/applications/sandbox
#
# - Considera usar secret management (AWS Secrets Manager, HashiCorp Vault) en producción

# --------------------------------------------
# Notification Service - Puerto 8082
# --------------------------------------------
# Notification Service envía notificaciones (email, SMS, push) a clientes.

NOTIFICATION_SERVICE_PORT=8082

# Configuración del Email Provider
EMAIL_PROVIDER=sendgrid
EMAIL_API_KEY=dummy_key
EMAIL_FROM=noreply@ecommerce.com

# Notas:
# - EMAIL_PROVIDER: Opciones: sendgrid, mailgun, ses (AWS Simple Email Service)
# - EMAIL_API_KEY: API key del proveedor. NUNCA commitees la key real.
#   SendGrid: Empieza con SG.
#   Mailgun: API key desde dashboard de Mailgun
#   AWS SES: Usa AWS credentials (access key + secret key)
# - EMAIL_FROM: Dirección de email para enviar notificaciones. Debe estar verificada en el proveedor.
#
#   IMPORTANTE: Verifica tu dominio/email antes de enviar en producción!
#   SendGrid: Dashboard > Settings > Sender Authentication > Verify Single Sender
#   Mailgun: Dashboard > Domains > Add Domain > Complete DNS verification
#   AWS SES: SES Console > Email Addresses > Verify a New Email Address
#
#   Sin verificación, los emails irán a spam o serán rechazados.

# --------------------------------------------
# Configuración Avanzada (Opcional)
# --------------------------------------------
# Estas variables son opcionales. Si no están definidas, los servicios usan valores por defecto.

# Logging
# LOG_LEVEL=INFO
# LOG_PATTERN=%d{yyyy-MM-dd HH:mm:ss} - %msg%n

# Kafka Avanzado
# KAFKA_ACKS=all
# KAFKA_RETRIES=3
# KAFKA_ENABLE_IDEMPOTENCE=true

# PostgreSQL Connection Pool (R2DBC)
# R2DBC_POOL_INITIAL_SIZE=10
# R2DBC_POOL_MAX_SIZE=20
# R2DBC_POOL_MAX_IDLE_TIME=30m

# MongoDB Connection Pool
# MONGO_POOL_MIN_SIZE=10
# MONGO_POOL_MAX_SIZE=50
# MONGO_POOL_MAX_WAIT_TIME=2000

# Timeouts
# HTTP_CLIENT_TIMEOUT=5000
# PAYMENT_GATEWAY_TIMEOUT=10000

# Circuit Breaker (Resilience4j)
# CIRCUIT_BREAKER_FAILURE_RATE_THRESHOLD=50
# CIRCUIT_BREAKER_WAIT_DURATION_IN_OPEN_STATE=60000

# --------------------------------------------
# Notas Finales
# --------------------------------------------
#
# SEGURIDAD:
# - NUNCA commitees .env con valores reales (passwords, API keys, secrets)
# - En CI/CD, inyecta variables de entorno desde secrets manager
# - Rota passwords y API keys regularmente (cada 90 días mínimo)
# - Usa diferentes credenciales para cada ambiente (dev, staging, prod)
#
# DOCKER COMPOSE:
# - Para iniciar solo infra: docker-compose up -d postgres mongodb kafka zookeeper
# - Para iniciar todo (infra + servicios): docker-compose --profile services up -d
# - Para ver logs: docker-compose logs -f [service-name]
# - Para detener todo: docker-compose down
# - Para limpiar volúmenes (CUIDADO - borra datos): docker-compose down -v
#
# DESARROLLO LOCAL:
# - Opción 1: Corre servicios en Docker (usa profile services)
# - Opción 2: Corre solo infra en Docker, servicios en tu IDE
#   - Cambia SPRING_PROFILES_ACTIVE=local
#   - Corre servicios desde IntelliJ/Eclipse
#   - Conectan a localhost:5432 (Postgres), localhost:27017 (Mongo), localhost:9092 (Kafka)
#
# TROUBLESHOOTING:
# - Si Kafka falla al iniciar, verifica que Zookeeper esté healthy primero
# - Si servicios no conectan a DB, verifica healthchecks: docker-compose ps
# - Si eventos no fluyen, revisa Kafka UI en http://localhost:8090
# - Para reiniciar Kafka limpiamente: docker-compose restart kafka
#
